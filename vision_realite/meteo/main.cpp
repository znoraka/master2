#include "opencv2/opencv.hpp"

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/algorithm.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Alpha_shape_2.h>

#include <list>

using namespace cv;

#define VARIATIONS_DEPTH 1

int cpt = 0;

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef K::FT FT;
typedef K::Point_2  Point;
typedef K::Segment_2  Segment;
typedef CGAL::Alpha_shape_vertex_base_2<K> Vb;
typedef CGAL::Alpha_shape_face_base_2<K>  Fb;
typedef CGAL::Triangulation_data_structure_2<Vb,Fb> Tds;
typedef CGAL::Delaunay_triangulation_2<K,Tds> Triangulation_2;
typedef CGAL::Alpha_shape_2<Triangulation_2>  Alpha_shape_2;
typedef Alpha_shape_2::Alpha_shape_edges_iterator Alpha_shape_edges_iterator;
template <class OutputIterator>
void
alpha_edges( const Alpha_shape_2&  A,
         OutputIterator out)
{
  for(Alpha_shape_edges_iterator it =  A.alpha_shape_edges_begin();
      it != A.alpha_shape_edges_end();
      ++it){
    *out++ = A.segment(*it);
  }
}

double distance(Vec3b v1, Vec3b v2) {
   Vec3b v = v1 - v2;
   return cv::norm(v);
}

void computeDifferenceMap(Mat frame, Mat toReturn) {
  auto topPixelDifference = [=] (Mat m, int i, int j, int value) {
    return m.at<uchar>(i - 1, j) - value;
  };

  auto leftPixelDifference = [=] (Mat m, int i, int j, int value) {
    return m.at<uchar>(i, j - 1) - value;
  };

  Mat grayScale;
  cvtColor(frame, grayScale, CV_RGB2GRAY);
  for (int i = 0; i < frame.rows; i++) {
    for (int j = 0; j < frame.cols; j++) {
      int tpd = 255;
      int lpd = 255;

      int value = grayScale.at<uchar>(i, j);

      if (i == 0) {
	//prendre le pixel du dessus
	tpd = topPixelDifference(grayScale, i, j, value);
      } else if (j == 0) {
	//prendre le pixel de gauche
	lpd = leftPixelDifference(grayScale, i, j, value);
      } else {
	lpd = leftPixelDifference(grayScale, i, j, value);
	tpd = topPixelDifference(grayScale, i, j, value);
      }

      if(abs(lpd) > abs(tpd)) {
	value = abs(lpd) * 20 + 127;
      } else {
	value = abs(tpd) * 20 + 127;
      }
      if(value > 255) value = 255;
      if(value < 0) value = 0;
      toReturn.at<uchar>(i, j) = value;
    }
  }
}

void updateVariationsMat(Mat newFrame, Mat variations, int currentIndex) {
  Mat grayScale;
  cvtColor(newFrame, grayScale, CV_RGB2GRAY);
  computeDifferenceMap(newFrame, grayScale);

  for (int i = 0; i < variations.rows; i++) {
    for (int j = 0; j < variations.cols; j++) {
      variations.at<Vec<uchar, VARIATIONS_DEPTH> >(i, j)[currentIndex] = grayScale.at<uchar>(i, j);
    }
  }
}

void computeVariations(Mat variations, Mat toReturn) {
  auto vecMean = [](Vec<uchar, VARIATIONS_DEPTH> v) {
    double sum = 0;
    for (int i = 0; i < VARIATIONS_DEPTH; i++) {
      sum += v[i];
    }
    return sum / VARIATIONS_DEPTH;
  };

  auto vecStdDev = [=] (Vec<uchar, VARIATIONS_DEPTH> v) {
    double sum = 0;
    double mean = vecMean(v);
    for (int i = 0; i < VARIATIONS_DEPTH; i++) {
      sum += pow(v[i] - mean, 2);
    }
    return sqrt(sum / VARIATIONS_DEPTH);
  };
  
  for (int i = 0; i < variations.rows; i++) {
    for (int j = 0; j < variations.cols; j++) {
      toReturn.at<uchar>(i, j) = vecStdDev(variations.at<Vec<uchar, VARIATIONS_DEPTH> >(i, j));
    }
  }
}

void drawAlphaShape(std::vector<Segment> segments, Mat image) {
  int thickness = 2;
  int lineType = 8;

  for(auto i : segments) {
    Point2f p1(i[0].y(), i[0].x());
    Point2f p2(i[1].y(), i[1].x());
    line( image,
	  p1,
	  p2,
	  Scalar( 0, 255, 0 ),
	  thickness,
	  lineType );
  }
}

int main(int argc, char** argv)
{
    VideoCapture cap;
    Mat variations;
    Mat base;
    // open the default camera, use something different from 0 otherwise;
    // Check VideoCapture documentation.
    if(!cap.open(0))
        return 0;

    int i = 0;

    BackgroundSubtractorMOG *pMOG = new BackgroundSubtractorMOG(); //MOG approach
    BackgroundSubtractorMOG2 *pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach

    for(;;)
    {
          Mat frame;
          cap >> frame;

	  Mat fgMaskMOG; //fg mask generated by MOG method
	  Mat fgMaskMOG2;

	  // pMOG->operator()(frame, fgMaskMOG);
	  // pMOG2->operator()(frame, fgMaskMOG2);

	  dilate(frame, frame, Mat());
	  dilate(frame, frame, Mat());
	  dilate(frame, frame, Mat());

	  erode(frame, frame, Mat());

	  // imshow("base frame", frame);


	  Mat computedVariations(frame.rows, frame.cols, CV_8UC1);

	  if(variations.rows == 0) {
	    cvtColor(frame, base, CV_RGB2GRAY);
		  
	    variations = Mat(frame.rows, frame.cols, CV_8UC(VARIATIONS_DEPTH));
	    std::cout << "created variations matrix" << std::endl;
	  }
	  updateVariationsMat(frame, variations, (i++) % VARIATIONS_DEPTH);
	  computeVariations(variations, computedVariations);

	  Mat temp;
	  cvtColor(frame, temp, CV_RGB2GRAY); 
	  cpt++;

	  for (int i = 0; i < variations.rows; i++) {
	    for (int j = 0; j < variations.cols; j++) {
	      if(abs(temp.at<uchar>(i, j) - base.at<uchar>(i, j)) < 15) {
	  	frame.at<Vec3b>(i, j)[0] = 0;
	  	frame.at<Vec3b>(i, j)[1] = 0;
	  	frame.at<Vec3b>(i, j)[2] = 0;
	      }
              if(cpt > 2 * VARIATIONS_DEPTH && computedVariations.at<uchar>(i, j) < 35) {
	      	  base.at<uchar>(i, j) = temp.at<uchar>(i, j);
	      }
	    }
	  }
	  Mat erosion_dst;
	  // erode( frame, erosion_dst, Mat());
	  dilate( frame, erosion_dst, Mat());
	  dilate( erosion_dst, erosion_dst, Mat());
	  erode( erosion_dst, erosion_dst, Mat());
	  dilate( erosion_dst, erosion_dst, Mat());
	  erode( erosion_dst, erosion_dst, Mat());
	  erode( erosion_dst, erosion_dst, Mat());

	  // imshow("FG Mask MOG", fgMaskMOG);
	  // imshow("FG Mask MOG 2", fgMaskMOG2);
    
	  if( frame.empty() ) break; // end of video stream
          // imshow("this is you, smile! :)", erosion_dst);
	  imshow("this is you, smile! :)1", frame);

	  std::list<K::Point_2> points;

	  for (int i = 0; i < frame.rows; i++) {
	    for (int j = 0; j < frame.cols; j++) {
	      if(erosion_dst.at<Vec3b>(i, j)[0] + 
		 erosion_dst.at<Vec3b>(i, j)[1] + 
		 erosion_dst.at<Vec3b>(i, j)[2] > 10) {
	  	points.push_back(K::Point_2(i, j));
	      }
	    }
	  }
	  
	  Alpha_shape_2 A(points.begin(), points.end(),
	  		  FT(50),
	  		  Alpha_shape_2::GENERAL);
	  std::vector<Segment> segments;
	  alpha_edges( A, std::back_inserter(segments));
	  drawAlphaShape(segments, frame);
	  imshow("this is you, smile! :)1", frame);
	  // std::cout << "Alpha Shape computed" << std::endl;
	  // std::cout << segments.size() << " alpha shape edges" << std::endl;
	  // std::cout << "Optimal alpha: " << *A.find_optimal_alpha(1)<<std::endl;
  

          if( waitKey(1) == 27 ) break; // stop capturing by pressing ESC 
    }
    // the camera will be closed automatically upon exit
    // cap.close();
    return 0;
}
